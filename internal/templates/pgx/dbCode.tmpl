{{define "dbCodePgx"}}

type DBTX interface {
	Exec(context.Context, string, ...any) (pgconn.CommandTag, error)
	Query(context.Context, string, ...any) (pgx.Rows, error)
	QueryRow(context.Context, string, ...any) pgx.Row
	Begin(context.Context) (pgx.Tx, error)
{{- if .UsesCopyFrom }}
	CopyFrom(ctx context.Context, tableName pgx.Identifier, columnNames []string, rowSrc pgx.CopyFromSource) (int64, error)
{{- end }}
{{- if .UsesBatch }}
	SendBatch(context.Context, *pgx.Batch) pgx.BatchResults
{{- end }}
}

// Query interfaces for executor pattern
type Query interface {
	SQL() string
	Args() []any
}

type QueryOne interface {
	Query
	Scan(row pgx.Row) error
}

type QueryMany interface {
	Query
	ScanRow(row pgx.Row) error
}

type QueryExec interface {
	Query
	SetRowsAffected(int64)
}

{{- if .UsesCopyFrom }}
type QueryCopyFrom interface {
	TableName() pgx.Identifier
	ColumnNames() []string
	CopyFromSource() pgx.CopyFromSource
	SetRowsCopied(int64)
}
{{- end }}

{{- if .UsesBatch }}
type QueryBatch interface {
	BuildBatch() *pgx.Batch
	ProcessResults(br pgx.BatchResults) error
}
{{- end }}

// QueryExecutor executes queries
type QueryExecutor interface {
	Execute(ctx context.Context, query Query) error
}

// Executor implements QueryExecutor using DBTX
type Executor struct {
	db DBTX
}

// NewExecutor creates a new Executor
func NewExecutor(db DBTX) *Executor {
	return &Executor{db: db}
}

// WithTx executes a function within a transaction
func (e *Executor) WithTx(ctx context.Context, fn func(QueryExecutor) error) error {
	tx, err := e.db.Begin(ctx)
	if err != nil {
		return err
	}

	executor := NewExecutor(tx)

	if err := fn(executor); err != nil {
		if rbErr := tx.Rollback(ctx); rbErr != nil {
			return fmt.Errorf("tx failed: %w, rollback failed: %v", err, rbErr)
		}
		return err
	}

	return tx.Commit(ctx)
}

func (e *Executor) Execute(ctx context.Context, query Query) error {
	switch q := query.(type) {
	case QueryOne:
		row := e.db.QueryRow(ctx, q.SQL(), q.Args()...)
		return q.Scan(row)
	case QueryMany:
		rows, err := e.db.Query(ctx, q.SQL(), q.Args()...)
		if err != nil {
			return err
		}
		defer rows.Close()
		for rows.Next() {
			if err := q.ScanRow(rows); err != nil {
				return err
			}
		}
		return rows.Err()
	case QueryExec:
		result, err := e.db.Exec(ctx, q.SQL(), q.Args()...)
		if err != nil {
			return err
		}
		q.SetRowsAffected(result.RowsAffected())
		return nil
{{- if .UsesCopyFrom }}
	case QueryCopyFrom:
		n, err := e.db.CopyFrom(ctx, q.TableName(), q.ColumnNames(), q.CopyFromSource())
		if err != nil {
			return err
		}
		q.SetRowsCopied(n)
		return nil
{{- end }}
{{- if .UsesBatch }}
	case QueryBatch:
		batch := q.BuildBatch()
		br := e.db.SendBatch(ctx, batch)
		return q.ProcessResults(br)
{{- end }}
	default:
		return nil
	}
}

// Compile-time interface checks
var (
	_ DBTX = (*pgx.Conn)(nil)
	_ DBTX = (pgx.Tx)(nil)
)
{{end}}

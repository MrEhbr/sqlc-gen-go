{{define "batchCodePgx"}}

var (
	ErrBatchAlreadyClosed = errors.New("batch already closed")
)

{{range .GoQueries}}
{{if eq (hasPrefix .Cmd ":batch") true }}
const {{.ConstantName}} = {{$.Q}}-- name: {{.MethodName}} {{.Cmd}}
{{escape .SQL}}
{{$.Q}}

type {{lowerTitle .MethodName}}BatchResults struct {
    br pgx.BatchResults
    tot int
    closed bool
}

{{if .Arg.EmitStruct}}
type {{.Arg.Type}} struct { {{- range .Arg.Struct.Fields}}
  {{.Name}} {{.Type}} {{if .Tag}}{{$.Q}}{{.Tag}}{{$.Q}}{{end}}
  {{- end}}
}
{{end}}

{{if .Ret.EmitStruct}}
type {{.Ret.Type}} struct { {{- range .Ret.Struct.Fields}}
  {{.Name}} {{.Type}} {{if .Tag}}{{$.Q}}{{.Tag}}{{$.Q}}{{end}}
  {{- end}}
}
{{end}}

type {{lowerTitle .MethodName}}Query struct {
	ex      QueryExecutor
	args    []{{.Arg.DefineType}}
	results *{{lowerTitle .MethodName}}BatchResults
}

func (q *{{lowerTitle .MethodName}}Query) SQL() string {
	return {{.ConstantName}}
}

func (q *{{lowerTitle .MethodName}}Query) Args() []any {
	return nil
}

func (q *{{lowerTitle .MethodName}}Query) BuildBatch() *pgx.Batch {
    batch := &pgx.Batch{}
    for _, a := range q.args {
        vals := []any{
        {{- if .Arg.Struct }}
        {{- range .Arg.Struct.Fields }}
            a.{{.Name}},
        {{- end }}
        {{- else }}
            a,
        {{- end }}
        }
        batch.Queue({{.ConstantName}}, vals...)
    }
    return batch
}

func (q *{{lowerTitle .MethodName}}Query) ProcessResults(br pgx.BatchResults) error {
	q.results = &{{lowerTitle .MethodName}}BatchResults{br, len(q.args), false}
	return nil
}

func New{{.MethodName}}Query(ex QueryExecutor) *{{lowerTitle .MethodName}}Query {
	return &{{lowerTitle .MethodName}}Query{ex: ex}
}

{{range .Comments}}//{{.}}
{{end -}}
func (q *{{lowerTitle .MethodName}}Query) Eval(ctx context.Context, {{.Arg.SlicePair}}) (*{{lowerTitle .MethodName}}BatchResults, error) {
	q.args = {{.Arg.Name}}
	if err := q.ex.Execute(ctx, q); err != nil {
		return nil, err
	}
	return q.results, nil
}

{{if eq .Cmd ":batchexec"}}
func (b *{{lowerTitle .MethodName}}BatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
   for t := 0; t < b.tot; t++ {
     if b.closed {
       if f != nil {
         f(t, ErrBatchAlreadyClosed)
       }
       continue
     }
     _, err := b.br.Exec()
     if f != nil {
        f(t, err)
     }
   }
}
{{end}}

{{if eq .Cmd ":batchmany"}}
func (b *{{lowerTitle .MethodName}}BatchResults) Query(f func(int, []{{.Ret.DefineType}}, error)) {
	defer b.br.Close()
   for t := 0; t < b.tot; t++ {
     {{- if $.EmitEmptySlices}}
     items := []{{.Ret.DefineType}}{}
     {{else}}
     var items []{{.Ret.DefineType}}
     {{end -}}
     if b.closed {
        if f != nil {
          f(t, items, ErrBatchAlreadyClosed)
        }
        continue
     }
     err := func() error {
       rows, err := b.br.Query()
       if err != nil {
         return err
       }
       defer rows.Close()
       for rows.Next() {
           var {{.Ret.Name}} {{.Ret.Type}}
           if err := rows.Scan({{.Ret.Scan}}); err != nil {
             return err
           }
           items = append(items, {{.Ret.ReturnName}})
        }
        return rows.Err()
      }()
      if f != nil {
        f(t, items, err)
      }
   }
}
{{end}}

{{if eq .Cmd ":batchone"}}
func (b *{{lowerTitle .MethodName}}BatchResults) QueryRow(f func(int, {{.Ret.DefineType}}, error)) {
	defer b.br.Close()
   for t := 0; t < b.tot; t++ {
     var {{.Ret.Name}} {{.Ret.Type}}
     if b.closed {
        if f != nil {
          f(t, {{if .Ret.IsPointer}}nil{{else}}{{.Ret.Name}}{{end}}, ErrBatchAlreadyClosed)
        }
        continue
     }
     row := b.br.QueryRow()
	  err := row.Scan({{.Ret.Scan}})
     if f != nil {
       f(t, {{.Ret.ReturnName}}, err)
     }
   }
}
{{end}}

func (b *{{lowerTitle .MethodName}}BatchResults) Close() error {
    b.closed = true
    return b.br.Close()
}
{{end}}
{{end}}
{{end}}

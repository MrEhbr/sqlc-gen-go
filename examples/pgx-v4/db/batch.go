// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: batch.go

package db

import (
	"context"
	"errors"

	"github.com/jackc/pgx/v4"
)

var (
	ErrBatchAlreadyClosed = errors.New("batch already closed")
)

const batchGetUsers = `-- name: BatchGetUsers :batchone
SELECT id, name, email, created_at FROM users
WHERE id = $1
`

type batchGetUsersBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type batchGetUsersQuery struct {
	ex      QueryExecutor
	args    []int64
	results *batchGetUsersBatchResults
}

func (q *batchGetUsersQuery) SQL() string {
	return batchGetUsers
}

func (q *batchGetUsersQuery) Args() []any {
	return nil
}

func (q *batchGetUsersQuery) BuildBatch() *pgx.Batch {
	batch := &pgx.Batch{}
	for _, a := range q.args {
		vals := []any{
			a,
		}
		batch.Queue(batchGetUsers, vals...)
	}
	return batch
}

func (q *batchGetUsersQuery) ProcessResults(br pgx.BatchResults) error {
	q.results = &batchGetUsersBatchResults{br, len(q.args), false}
	return nil
}

func NewBatchGetUsersQuery(ex QueryExecutor) *batchGetUsersQuery {
	return &batchGetUsersQuery{ex: ex}
}

func (q *batchGetUsersQuery) Eval(ctx context.Context, id []int64) (*batchGetUsersBatchResults, error) {
	q.args = id
	if err := q.ex.Execute(ctx, q); err != nil {
		return nil, err
	}
	return q.results, nil
}

func (b *batchGetUsersBatchResults) QueryRow(f func(int, User, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		var i User
		if b.closed {
			if f != nil {
				f(t, i, ErrBatchAlreadyClosed)
			}
			continue
		}
		row := b.br.QueryRow()
		err := row.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.CreatedAt,
		)
		if f != nil {
			f(t, i, err)
		}
	}
}

func (b *batchGetUsersBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const batchInsertUsers = `-- name: BatchInsertUsers :batchexec
INSERT INTO users (name, email)
VALUES ($1, $2)
`

type batchInsertUsersBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type BatchInsertUsersParams struct {
	Name  string `json:"name"`
	Email string `json:"email"`
}

type batchInsertUsersQuery struct {
	ex      QueryExecutor
	args    []BatchInsertUsersParams
	results *batchInsertUsersBatchResults
}

func (q *batchInsertUsersQuery) SQL() string {
	return batchInsertUsers
}

func (q *batchInsertUsersQuery) Args() []any {
	return nil
}

func (q *batchInsertUsersQuery) BuildBatch() *pgx.Batch {
	batch := &pgx.Batch{}
	for _, a := range q.args {
		vals := []any{
			a.Name,
			a.Email,
		}
		batch.Queue(batchInsertUsers, vals...)
	}
	return batch
}

func (q *batchInsertUsersQuery) ProcessResults(br pgx.BatchResults) error {
	q.results = &batchInsertUsersBatchResults{br, len(q.args), false}
	return nil
}

func NewBatchInsertUsersQuery(ex QueryExecutor) *batchInsertUsersQuery {
	return &batchInsertUsersQuery{ex: ex}
}

func (q *batchInsertUsersQuery) Eval(ctx context.Context, arg []BatchInsertUsersParams) (*batchInsertUsersBatchResults, error) {
	q.args = arg
	if err := q.ex.Execute(ctx, q); err != nil {
		return nil, err
	}
	return q.results, nil
}

func (b *batchInsertUsersBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *batchInsertUsersBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const batchListUsersByEmail = `-- name: BatchListUsersByEmail :batchmany
SELECT id, name, email, created_at FROM users
WHERE email LIKE $1
`

type batchListUsersByEmailBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type batchListUsersByEmailQuery struct {
	ex      QueryExecutor
	args    []string
	results *batchListUsersByEmailBatchResults
}

func (q *batchListUsersByEmailQuery) SQL() string {
	return batchListUsersByEmail
}

func (q *batchListUsersByEmailQuery) Args() []any {
	return nil
}

func (q *batchListUsersByEmailQuery) BuildBatch() *pgx.Batch {
	batch := &pgx.Batch{}
	for _, a := range q.args {
		vals := []any{
			a,
		}
		batch.Queue(batchListUsersByEmail, vals...)
	}
	return batch
}

func (q *batchListUsersByEmailQuery) ProcessResults(br pgx.BatchResults) error {
	q.results = &batchListUsersByEmailBatchResults{br, len(q.args), false}
	return nil
}

func NewBatchListUsersByEmailQuery(ex QueryExecutor) *batchListUsersByEmailQuery {
	return &batchListUsersByEmailQuery{ex: ex}
}

func (q *batchListUsersByEmailQuery) Eval(ctx context.Context, email []string) (*batchListUsersByEmailBatchResults, error) {
	q.args = email
	if err := q.ex.Execute(ctx, q); err != nil {
		return nil, err
	}
	return q.results, nil
}

func (b *batchListUsersByEmailBatchResults) Query(f func(int, []User, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		var items []User
		if b.closed {
			if f != nil {
				f(t, items, ErrBatchAlreadyClosed)
			}
			continue
		}
		err := func() error {
			rows, err := b.br.Query()
			if err != nil {
				return err
			}
			defer rows.Close()
			for rows.Next() {
				var i User
				if err := rows.Scan(
					&i.ID,
					&i.Name,
					&i.Email,
					&i.CreatedAt,
				); err != nil {
					return err
				}
				items = append(items, i)
			}
			return rows.Err()
		}()
		if f != nil {
			f(t, items, err)
		}
	}
}

func (b *batchListUsersByEmailBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const batchUpdateEmails = `-- name: BatchUpdateEmails :batchexec
UPDATE users
SET email = $2
WHERE id = $1
`

type batchUpdateEmailsBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type BatchUpdateEmailsParams struct {
	ID    int64  `json:"id"`
	Email string `json:"email"`
}

type batchUpdateEmailsQuery struct {
	ex      QueryExecutor
	args    []BatchUpdateEmailsParams
	results *batchUpdateEmailsBatchResults
}

func (q *batchUpdateEmailsQuery) SQL() string {
	return batchUpdateEmails
}

func (q *batchUpdateEmailsQuery) Args() []any {
	return nil
}

func (q *batchUpdateEmailsQuery) BuildBatch() *pgx.Batch {
	batch := &pgx.Batch{}
	for _, a := range q.args {
		vals := []any{
			a.ID,
			a.Email,
		}
		batch.Queue(batchUpdateEmails, vals...)
	}
	return batch
}

func (q *batchUpdateEmailsQuery) ProcessResults(br pgx.BatchResults) error {
	q.results = &batchUpdateEmailsBatchResults{br, len(q.args), false}
	return nil
}

func NewBatchUpdateEmailsQuery(ex QueryExecutor) *batchUpdateEmailsQuery {
	return &batchUpdateEmailsQuery{ex: ex}
}

func (q *batchUpdateEmailsQuery) Eval(ctx context.Context, arg []BatchUpdateEmailsParams) (*batchUpdateEmailsBatchResults, error) {
	q.args = arg
	if err := q.ex.Execute(ctx, q); err != nil {
		return nil, err
	}
	return q.results, nil
}

func (b *batchUpdateEmailsBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *batchUpdateEmailsBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/sqlc-dev/sqlc-gen-go/examples/pgx-split-packages/db"
	"github.com/sqlc-dev/sqlc-gen-go/examples/pgx-split-packages/models"
)

const createAccount = `-- name: CreateAccount :one
INSERT INTO accounts (username, email, role, status)
VALUES ($1, $2, $3, $4)
RETURNING id, username, email, role, status, created_at, updated_at
`

type CreateAccountParams struct {
	Username string               `json:"username"`
	Email    string               `json:"email"`
	Role     models.UserRole      `json:"role"`
	Status   models.AccountStatus `json:"status"`
}

type CreateAccountQuery struct {
	ex     db.QueryExecutor
	arg    CreateAccountParams
	result models.Account
}

func (q *CreateAccountQuery) SQL() string {
	return createAccount
}

func (q *CreateAccountQuery) Args() []any {
	return []any{q.arg.Username, q.arg.Email, q.arg.Role, q.arg.Status}
}

func (q *CreateAccountQuery) Scan(row pgx.Row) error {
	return row.Scan(&q.result.ID, &q.result.Username, &q.result.Email, &q.result.Role, &q.result.Status, &q.result.CreatedAt, &q.result.UpdatedAt)
}

func (q *CreateAccountQuery) Result() models.Account {
	return q.result
}
func (q *CreateAccountQuery) Eval(ctx context.Context, arg CreateAccountParams) (models.Account, error) {
	q.arg = arg
	if err := q.ex.Execute(ctx, q); err != nil {
		var zero models.Account
		return zero, err
	}
	return q.Result(), nil
}

func NewCreateAccountQuery(ex db.QueryExecutor) *CreateAccountQuery {
	return &CreateAccountQuery{ex: ex}
}

const createPost = `-- name: CreatePost :one
INSERT INTO posts (account_id, title, content, published)
VALUES ($1, $2, $3, $4)
RETURNING id, account_id, title, content, published, created_at
`

type CreatePostParams struct {
	AccountID int64  `json:"account_id"`
	Title     string `json:"title"`
	Content   string `json:"content"`
	Published bool   `json:"published"`
}

type CreatePostQuery struct {
	ex     db.QueryExecutor
	arg    CreatePostParams
	result models.Post
}

func (q *CreatePostQuery) SQL() string {
	return createPost
}

func (q *CreatePostQuery) Args() []any {
	return []any{q.arg.AccountID, q.arg.Title, q.arg.Content, q.arg.Published}
}

func (q *CreatePostQuery) Scan(row pgx.Row) error {
	return row.Scan(&q.result.ID, &q.result.AccountID, &q.result.Title, &q.result.Content, &q.result.Published, &q.result.CreatedAt)
}

func (q *CreatePostQuery) Result() models.Post {
	return q.result
}
func (q *CreatePostQuery) Eval(ctx context.Context, arg CreatePostParams) (models.Post, error) {
	q.arg = arg
	if err := q.ex.Execute(ctx, q); err != nil {
		var zero models.Post
		return zero, err
	}
	return q.Result(), nil
}

func NewCreatePostQuery(ex db.QueryExecutor) *CreatePostQuery {
	return &CreatePostQuery{ex: ex}
}

const deleteAccount = `-- name: DeleteAccount :exec
DELETE FROM accounts
WHERE id = $1
`

type DeleteAccountQuery struct {
	ex           db.QueryExecutor
	id           int64
	rowsAffected int64
}

func (q *DeleteAccountQuery) SQL() string {
	return deleteAccount
}

func (q *DeleteAccountQuery) Args() []any {
	return []any{q.id}
}

func (q *DeleteAccountQuery) SetRowsAffected(n int64) {
	q.rowsAffected = n
}
func (q *DeleteAccountQuery) Eval(ctx context.Context, id int64) error {
	q.id = id
	return q.ex.Execute(ctx, q)
}

func NewDeleteAccountQuery(ex db.QueryExecutor) *DeleteAccountQuery {
	return &DeleteAccountQuery{ex: ex}
}

const getAccount = `-- name: GetAccount :one
SELECT id, username, email, role, status, created_at, updated_at FROM accounts
WHERE id = $1
`

type GetAccountQuery struct {
	ex     db.QueryExecutor
	id     int64
	result models.Account
}

func (q *GetAccountQuery) SQL() string {
	return getAccount
}

func (q *GetAccountQuery) Args() []any {
	return []any{q.id}
}

func (q *GetAccountQuery) Scan(row pgx.Row) error {
	return row.Scan(&q.result.ID, &q.result.Username, &q.result.Email, &q.result.Role, &q.result.Status, &q.result.CreatedAt, &q.result.UpdatedAt)
}

func (q *GetAccountQuery) Result() models.Account {
	return q.result
}
func (q *GetAccountQuery) Eval(ctx context.Context, id int64) (models.Account, error) {
	q.id = id
	if err := q.ex.Execute(ctx, q); err != nil {
		var zero models.Account
		return zero, err
	}
	return q.Result(), nil
}

func NewGetAccountQuery(ex db.QueryExecutor) *GetAccountQuery {
	return &GetAccountQuery{ex: ex}
}

const getAccountByUsername = `-- name: GetAccountByUsername :one
SELECT id, username, email, role, status, created_at, updated_at FROM accounts
WHERE username = $1
`

type GetAccountByUsernameQuery struct {
	ex       db.QueryExecutor
	username string
	result   models.Account
}

func (q *GetAccountByUsernameQuery) SQL() string {
	return getAccountByUsername
}

func (q *GetAccountByUsernameQuery) Args() []any {
	return []any{q.username}
}

func (q *GetAccountByUsernameQuery) Scan(row pgx.Row) error {
	return row.Scan(&q.result.ID, &q.result.Username, &q.result.Email, &q.result.Role, &q.result.Status, &q.result.CreatedAt, &q.result.UpdatedAt)
}

func (q *GetAccountByUsernameQuery) Result() models.Account {
	return q.result
}
func (q *GetAccountByUsernameQuery) Eval(ctx context.Context, username string) (models.Account, error) {
	q.username = username
	if err := q.ex.Execute(ctx, q); err != nil {
		var zero models.Account
		return zero, err
	}
	return q.Result(), nil
}

func NewGetAccountByUsernameQuery(ex db.QueryExecutor) *GetAccountByUsernameQuery {
	return &GetAccountByUsernameQuery{ex: ex}
}

const getPost = `-- name: GetPost :one
SELECT p.id, p.account_id, p.title, p.content, p.published, p.created_at, a.username, a.role
FROM posts p
JOIN accounts a ON p.account_id = a.id
WHERE p.id = $1
`

type GetPostRow struct {
	ID        int64              `json:"id"`
	AccountID int64              `json:"account_id"`
	Title     string             `json:"title"`
	Content   string             `json:"content"`
	Published bool               `json:"published"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	Username  string             `json:"username"`
	Role      models.UserRole    `json:"role"`
}

type GetPostQuery struct {
	ex     db.QueryExecutor
	id     int64
	result GetPostRow
}

func (q *GetPostQuery) SQL() string {
	return getPost
}

func (q *GetPostQuery) Args() []any {
	return []any{q.id}
}

func (q *GetPostQuery) Scan(row pgx.Row) error {
	return row.Scan(&q.result.ID, &q.result.AccountID, &q.result.Title, &q.result.Content, &q.result.Published, &q.result.CreatedAt, &q.result.Username, &q.result.Role)
}

func (q *GetPostQuery) Result() GetPostRow {
	return q.result
}
func (q *GetPostQuery) Eval(ctx context.Context, id int64) (GetPostRow, error) {
	q.id = id
	if err := q.ex.Execute(ctx, q); err != nil {
		var zero GetPostRow
		return zero, err
	}
	return q.Result(), nil
}

func NewGetPostQuery(ex db.QueryExecutor) *GetPostQuery {
	return &GetPostQuery{ex: ex}
}

const listAccounts = `-- name: ListAccounts :many
SELECT id, username, email, role, status, created_at, updated_at FROM accounts
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListAccountsQuery struct {
	ex      db.QueryExecutor
	limit   int32
	offset  int32
	results []models.Account
}

func (q *ListAccountsQuery) SQL() string {
	return listAccounts
}

func (q *ListAccountsQuery) Args() []any {
	return []any{q.limit, q.offset}
}

func (q *ListAccountsQuery) ScanRow(row pgx.Row) error {
	var i models.Account
	if err := row.Scan(&i.ID, &i.Username, &i.Email, &i.Role, &i.Status, &i.CreatedAt, &i.UpdatedAt); err != nil {
		return err
	}
	q.results = append(q.results, i)
	return nil
}

func (q *ListAccountsQuery) Results() []models.Account {
	return q.results
}

func (q *ListAccountsQuery) Eval(ctx context.Context, limit int32, offset int32) ([]models.Account, error) {
	q.limit = limit
	q.offset = offset
	q.results = nil
	if err := q.ex.Execute(ctx, q); err != nil {
		return nil, err
	}
	return q.Results(), nil
}

func NewListAccountsQuery(ex db.QueryExecutor) *ListAccountsQuery {
	return &ListAccountsQuery{ex: ex}
}

const listAccountsByRole = `-- name: ListAccountsByRole :many
SELECT id, username, email, role, status, created_at, updated_at FROM accounts
WHERE role = $1
ORDER BY created_at DESC
`

type ListAccountsByRoleQuery struct {
	ex      db.QueryExecutor
	role    models.UserRole
	results []models.Account
}

func (q *ListAccountsByRoleQuery) SQL() string {
	return listAccountsByRole
}

func (q *ListAccountsByRoleQuery) Args() []any {
	return []any{q.role}
}

func (q *ListAccountsByRoleQuery) ScanRow(row pgx.Row) error {
	var i models.Account
	if err := row.Scan(&i.ID, &i.Username, &i.Email, &i.Role, &i.Status, &i.CreatedAt, &i.UpdatedAt); err != nil {
		return err
	}
	q.results = append(q.results, i)
	return nil
}

func (q *ListAccountsByRoleQuery) Results() []models.Account {
	return q.results
}

func (q *ListAccountsByRoleQuery) Eval(ctx context.Context, role models.UserRole) ([]models.Account, error) {
	q.role = role
	q.results = nil
	if err := q.ex.Execute(ctx, q); err != nil {
		return nil, err
	}
	return q.Results(), nil
}

func NewListAccountsByRoleQuery(ex db.QueryExecutor) *ListAccountsByRoleQuery {
	return &ListAccountsByRoleQuery{ex: ex}
}

const listPostsByAccount = `-- name: ListPostsByAccount :many
SELECT id, account_id, title, content, published, created_at FROM posts
WHERE account_id = $1
ORDER BY created_at DESC
`

type ListPostsByAccountQuery struct {
	ex        db.QueryExecutor
	accountID int64
	results   []models.Post
}

func (q *ListPostsByAccountQuery) SQL() string {
	return listPostsByAccount
}

func (q *ListPostsByAccountQuery) Args() []any {
	return []any{q.accountID}
}

func (q *ListPostsByAccountQuery) ScanRow(row pgx.Row) error {
	var i models.Post
	if err := row.Scan(&i.ID, &i.AccountID, &i.Title, &i.Content, &i.Published, &i.CreatedAt); err != nil {
		return err
	}
	q.results = append(q.results, i)
	return nil
}

func (q *ListPostsByAccountQuery) Results() []models.Post {
	return q.results
}

func (q *ListPostsByAccountQuery) Eval(ctx context.Context, accountID int64) ([]models.Post, error) {
	q.accountID = accountID
	q.results = nil
	if err := q.ex.Execute(ctx, q); err != nil {
		return nil, err
	}
	return q.Results(), nil
}

func NewListPostsByAccountQuery(ex db.QueryExecutor) *ListPostsByAccountQuery {
	return &ListPostsByAccountQuery{ex: ex}
}

const publishPost = `-- name: PublishPost :execrows
UPDATE posts
SET published = true
WHERE id = $1 AND published = false
`

type PublishPostQuery struct {
	ex           db.QueryExecutor
	id           int64
	rowsAffected int64
}

func (q *PublishPostQuery) SQL() string {
	return publishPost
}

func (q *PublishPostQuery) Args() []any {
	return []any{q.id}
}

func (q *PublishPostQuery) SetRowsAffected(n int64) {
	q.rowsAffected = n
}

func (q *PublishPostQuery) Eval(ctx context.Context, id int64) (int64, error) {
	q.id = id
	if err := q.ex.Execute(ctx, q); err != nil {
		return 0, err
	}
	return q.rowsAffected, nil
}

func NewPublishPostQuery(ex db.QueryExecutor) *PublishPostQuery {
	return &PublishPostQuery{ex: ex}
}

const updateAccountStatus = `-- name: UpdateAccountStatus :execrows
UPDATE accounts
SET status = $2, updated_at = NOW()
WHERE id = $1
`

type UpdateAccountStatusQuery struct {
	ex           db.QueryExecutor
	iD           int64
	status       models.AccountStatus
	rowsAffected int64
}

func (q *UpdateAccountStatusQuery) SQL() string {
	return updateAccountStatus
}

func (q *UpdateAccountStatusQuery) Args() []any {
	return []any{q.iD, q.status}
}

func (q *UpdateAccountStatusQuery) SetRowsAffected(n int64) {
	q.rowsAffected = n
}

func (q *UpdateAccountStatusQuery) Eval(ctx context.Context, iD int64, status models.AccountStatus) (int64, error) {
	q.iD = iD
	q.status = status
	if err := q.ex.Execute(ctx, q); err != nil {
		return 0, err
	}
	return q.rowsAffected, nil
}

func NewUpdateAccountStatusQuery(ex db.QueryExecutor) *UpdateAccountStatusQuery {
	return &UpdateAccountStatusQuery{ex: ex}
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package db

import (
	"context"
	"database/sql"
)

const createUser = `-- name: CreateUser :one
INSERT INTO users (name, email)
VALUES ($1, $2)
RETURNING id, name, email, created_at
`

type CreateUserQuery struct {
	ex     QueryExecutor
	name   string
	email  string
	result User
}

func (q *CreateUserQuery) SQL() string {
	return createUser
}

func (q *CreateUserQuery) Args() []any {
	return []any{q.name, q.email}
}

func (q *CreateUserQuery) Scan(row *sql.Row) error {
	return row.Scan(&q.result.ID, &q.result.Name, &q.result.Email, &q.result.CreatedAt)
}

func (q *CreateUserQuery) Result() User {
	return q.result
}
func (q *CreateUserQuery) Eval(ctx context.Context, name string, email string) (User, error) {
	q.name = name
	q.email = email
	if err := q.ex.Execute(ctx, q); err != nil {
		var zero User
		return zero, err
	}
	return q.Result(), nil
}

func NewCreateUserQuery(ex QueryExecutor) *CreateUserQuery {
	return &CreateUserQuery{ex: ex}
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE id = $1
`

type DeleteUserQuery struct {
	ex           QueryExecutor
	id           int64
	rowsAffected int64
}

func (q *DeleteUserQuery) SQL() string {
	return deleteUser
}

func (q *DeleteUserQuery) Args() []any {
	return []any{q.id}
}

func (q *DeleteUserQuery) SetRowsAffected(n int64) {
	q.rowsAffected = n
}
func (q *DeleteUserQuery) Eval(ctx context.Context, id int64) error {
	q.id = id
	return q.ex.Execute(ctx, q)
}

func NewDeleteUserQuery(ex QueryExecutor) *DeleteUserQuery {
	return &DeleteUserQuery{ex: ex}
}

const getUser = `-- name: GetUser :one
SELECT id, name, email, created_at FROM users
WHERE id = $1
`

type GetUserQuery struct {
	ex     QueryExecutor
	id     int64
	result User
}

func (q *GetUserQuery) SQL() string {
	return getUser
}

func (q *GetUserQuery) Args() []any {
	return []any{q.id}
}

func (q *GetUserQuery) Scan(row *sql.Row) error {
	return row.Scan(&q.result.ID, &q.result.Name, &q.result.Email, &q.result.CreatedAt)
}

func (q *GetUserQuery) Result() User {
	return q.result
}
func (q *GetUserQuery) Eval(ctx context.Context, id int64) (User, error) {
	q.id = id
	if err := q.ex.Execute(ctx, q); err != nil {
		var zero User
		return zero, err
	}
	return q.Result(), nil
}

func NewGetUserQuery(ex QueryExecutor) *GetUserQuery {
	return &GetUserQuery{ex: ex}
}

const getUserForUpdate = `-- name: GetUserForUpdate :one

SELECT id, name, email, created_at FROM users
WHERE id = $1
FOR UPDATE
`

// Note: :execlastid not used because PostgreSQL doesn't support LastInsertId()
// Use :one with RETURNING instead
type GetUserForUpdateQuery struct {
	ex     QueryExecutor
	id     int64
	result User
}

func (q *GetUserForUpdateQuery) SQL() string {
	return getUserForUpdate
}

func (q *GetUserForUpdateQuery) Args() []any {
	return []any{q.id}
}

func (q *GetUserForUpdateQuery) Scan(row *sql.Row) error {
	return row.Scan(&q.result.ID, &q.result.Name, &q.result.Email, &q.result.CreatedAt)
}

func (q *GetUserForUpdateQuery) Result() User {
	return q.result
}
func (q *GetUserForUpdateQuery) Eval(ctx context.Context, id int64) (User, error) {
	q.id = id
	if err := q.ex.Execute(ctx, q); err != nil {
		var zero User
		return zero, err
	}
	return q.Result(), nil
}

func NewGetUserForUpdateQuery(ex QueryExecutor) *GetUserForUpdateQuery {
	return &GetUserForUpdateQuery{ex: ex}
}

const listUsers = `-- name: ListUsers :many
SELECT id, name, email, created_at FROM users
ORDER BY created_at DESC
`

type ListUsersQuery struct {
	ex      QueryExecutor
	results []User
}

func (q *ListUsersQuery) SQL() string {
	return listUsers
}

func (q *ListUsersQuery) Args() []any {
	return nil
}

func (q *ListUsersQuery) ScanRow(row *sql.Rows) error {
	var i User
	if err := row.Scan(&i.ID, &i.Name, &i.Email, &i.CreatedAt); err != nil {
		return err
	}
	q.results = append(q.results, i)
	return nil
}

func (q *ListUsersQuery) Results() []User {
	return q.results
}
func (q *ListUsersQuery) Eval(ctx context.Context) ([]User, error) {
	q.results = nil
	if err := q.ex.Execute(ctx, q); err != nil {
		return nil, err
	}
	return q.Results(), nil
}

func NewListUsersQuery(ex QueryExecutor) *ListUsersQuery {
	return &ListUsersQuery{ex: ex}
}

const updateUserEmail = `-- name: UpdateUserEmail :execrows
UPDATE users
SET email = $2
WHERE id = $1
`

type UpdateUserEmailQuery struct {
	ex           QueryExecutor
	iD           int64
	email        string
	rowsAffected int64
}

func (q *UpdateUserEmailQuery) SQL() string {
	return updateUserEmail
}

func (q *UpdateUserEmailQuery) Args() []any {
	return []any{q.iD, q.email}
}

func (q *UpdateUserEmailQuery) SetRowsAffected(n int64) {
	q.rowsAffected = n
}
func (q *UpdateUserEmailQuery) Eval(ctx context.Context, iD int64, email string) (int64, error) {
	q.iD = iD
	q.email = email
	if err := q.ex.Execute(ctx, q); err != nil {
		return 0, err
	}
	return q.rowsAffected, nil
}

func NewUpdateUserEmailQuery(ex QueryExecutor) *UpdateUserEmailQuery {
	return &UpdateUserEmailQuery{ex: ex}
}

const updateUserName = `-- name: UpdateUserName :execresult
UPDATE users
SET name = $2
WHERE id = $1
`

type UpdateUserNameQuery struct {
	ex   QueryExecutor
	iD   int64
	name string
}

func (q *UpdateUserNameQuery) SQL() string {
	return updateUserName
}

func (q *UpdateUserNameQuery) Args() []any {
	return []any{q.iD, q.name}
}

func NewUpdateUserNameQuery(ex QueryExecutor) *UpdateUserNameQuery {
	return &UpdateUserNameQuery{ex: ex}
}

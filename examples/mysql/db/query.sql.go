// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package db

import (
	"context"
	"database/sql"
)

const createUser = `-- name: CreateUser :execresult
INSERT INTO users (name, email)
VALUES (?, ?)
`

type CreateUserQuery struct {
	ex    QueryExecutor
	name  string
	email string
}

func (q *CreateUserQuery) SQL() string {
	return createUser
}

func (q *CreateUserQuery) Args() []any {
	return []any{q.name, q.email}
}

func NewCreateUserQuery(ex QueryExecutor) *CreateUserQuery {
	return &CreateUserQuery{ex: ex}
}

const createUserGetID = `-- name: CreateUserGetID :execlastid
INSERT INTO users (name, email)
VALUES (?, ?)
`

type CreateUserGetIDQuery struct {
	ex           QueryExecutor
	name         string
	email        string
	lastID       int64
	rowsAffected int64
}

func (q *CreateUserGetIDQuery) SQL() string {
	return createUserGetID
}

func (q *CreateUserGetIDQuery) Args() []any {
	return []any{q.name, q.email}
}

func (q *CreateUserGetIDQuery) SetLastInsertID(n int64) {
	q.lastID = n
}

func (q *CreateUserGetIDQuery) SetRowsAffected(n int64) {
	q.rowsAffected = n
}
func (q *CreateUserGetIDQuery) Eval(ctx context.Context, name string, email string) (int64, error) {
	q.name = name
	q.email = email
	if err := q.ex.Execute(ctx, q); err != nil {
		return 0, err
	}
	return q.lastID, nil
}

func NewCreateUserGetIDQuery(ex QueryExecutor) *CreateUserGetIDQuery {
	return &CreateUserGetIDQuery{ex: ex}
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE id = ?
`

type DeleteUserQuery struct {
	ex           QueryExecutor
	id           int64
	rowsAffected int64
}

func (q *DeleteUserQuery) SQL() string {
	return deleteUser
}

func (q *DeleteUserQuery) Args() []any {
	return []any{q.id}
}

func (q *DeleteUserQuery) SetRowsAffected(n int64) {
	q.rowsAffected = n
}
func (q *DeleteUserQuery) Eval(ctx context.Context, id int64) error {
	q.id = id
	return q.ex.Execute(ctx, q)
}

func NewDeleteUserQuery(ex QueryExecutor) *DeleteUserQuery {
	return &DeleteUserQuery{ex: ex}
}

const getUser = `-- name: GetUser :one
SELECT id, name, email, created_at FROM users
WHERE id = ?
`

type GetUserQuery struct {
	ex     QueryExecutor
	id     int64
	result User
}

func (q *GetUserQuery) SQL() string {
	return getUser
}

func (q *GetUserQuery) Args() []any {
	return []any{q.id}
}

func (q *GetUserQuery) Scan(row *sql.Row) error {
	return row.Scan(&q.result.ID, &q.result.Name, &q.result.Email, &q.result.CreatedAt)
}

func (q *GetUserQuery) Result() User {
	return q.result
}
func (q *GetUserQuery) Eval(ctx context.Context, id int64) (User, error) {
	q.id = id
	if err := q.ex.Execute(ctx, q); err != nil {
		var zero User
		return zero, err
	}
	return q.Result(), nil
}

func NewGetUserQuery(ex QueryExecutor) *GetUserQuery {
	return &GetUserQuery{ex: ex}
}

const listUsers = `-- name: ListUsers :many
SELECT id, name, email, created_at FROM users
ORDER BY created_at DESC
`

type ListUsersQuery struct {
	ex      QueryExecutor
	results []User
}

func (q *ListUsersQuery) SQL() string {
	return listUsers
}

func (q *ListUsersQuery) Args() []any {
	return nil
}

func (q *ListUsersQuery) ScanRow(row *sql.Rows) error {
	var i User
	if err := row.Scan(&i.ID, &i.Name, &i.Email, &i.CreatedAt); err != nil {
		return err
	}
	q.results = append(q.results, i)
	return nil
}

func (q *ListUsersQuery) Results() []User {
	return q.results
}
func (q *ListUsersQuery) Eval(ctx context.Context) ([]User, error) {
	q.results = nil
	if err := q.ex.Execute(ctx, q); err != nil {
		return nil, err
	}
	return q.Results(), nil
}

func NewListUsersQuery(ex QueryExecutor) *ListUsersQuery {
	return &ListUsersQuery{ex: ex}
}

const updateUserEmail = `-- name: UpdateUserEmail :execresult
UPDATE users
SET email = ?
WHERE id = ?
`

type UpdateUserEmailQuery struct {
	ex    QueryExecutor
	email string
	iD    int64
}

func (q *UpdateUserEmailQuery) SQL() string {
	return updateUserEmail
}

func (q *UpdateUserEmailQuery) Args() []any {
	return []any{q.email, q.iD}
}

func NewUpdateUserEmailQuery(ex QueryExecutor) *UpdateUserEmailQuery {
	return &UpdateUserEmailQuery{ex: ex}
}

const updateUserName = `-- name: UpdateUserName :execrows
UPDATE users
SET name = ?
WHERE id = ?
`

type UpdateUserNameQuery struct {
	ex           QueryExecutor
	name         string
	iD           int64
	rowsAffected int64
}

func (q *UpdateUserNameQuery) SQL() string {
	return updateUserName
}

func (q *UpdateUserNameQuery) Args() []any {
	return []any{q.name, q.iD}
}

func (q *UpdateUserNameQuery) SetRowsAffected(n int64) {
	q.rowsAffected = n
}
func (q *UpdateUserNameQuery) Eval(ctx context.Context, name string, iD int64) (int64, error) {
	q.name = name
	q.iD = iD
	if err := q.ex.Execute(ctx, q); err != nil {
		return 0, err
	}
	return q.rowsAffected, nil
}

func NewUpdateUserNameQuery(ex QueryExecutor) *UpdateUserNameQuery {
	return &UpdateUserNameQuery{ex: ex}
}

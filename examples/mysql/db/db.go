// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0

package db

import (
	"context"
	"database/sql"
	"fmt"
)

type DBTX interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	PrepareContext(context.Context, string) (*sql.Stmt, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

type DBTXWithTx interface {
	DBTX
	BeginTx(context.Context, *sql.TxOptions) (*sql.Tx, error)
}

// Query interfaces for executor pattern
type Query interface {
	SQL() string
	Args() []any
}

type QueryOne interface {
	Query
	Scan(row *sql.Row) error
}

type QueryMany interface {
	Query
	ScanRow(row *sql.Rows) error
}

type QueryExec interface {
	Query
	SetRowsAffected(int64)
}

type QueryExecLastID interface {
	Query
	SetLastInsertID(int64)
	SetRowsAffected(int64)
}

// QueryExecutor executes queries
type QueryExecutor interface {
	Execute(ctx context.Context, query Query) error
}

// Executor implements QueryExecutor using DBTX
type Executor struct {
	db       DBTX
	dbWithTx DBTXWithTx
}

// NewExecutor creates a new Executor
func NewExecutor(db DBTX) *Executor {
	dbWithTx, _ := db.(DBTXWithTx)
	return &Executor{
		db:       db,
		dbWithTx: dbWithTx,
	}
}

// WithTx executes a function within a transaction
func (e *Executor) WithTx(ctx context.Context, fn func(QueryExecutor) error) error {
	if e.dbWithTx == nil {
		return fmt.Errorf("database does not support transactions")
	}

	tx, err := e.dbWithTx.BeginTx(ctx, nil)
	if err != nil {
		return err
	}

	executor := NewExecutor(tx)

	if err := fn(executor); err != nil {
		if rbErr := tx.Rollback(); rbErr != nil {
			return fmt.Errorf("tx failed: %w, rollback failed: %v", err, rbErr)
		}
		return err
	}

	return tx.Commit()
}

func (e *Executor) Execute(ctx context.Context, query Query) error {
	switch q := query.(type) {
	case QueryOne:
		row := e.db.QueryRowContext(ctx, q.SQL(), q.Args()...)
		return q.Scan(row)
	case QueryMany:
		rows, err := e.db.QueryContext(ctx, q.SQL(), q.Args()...)
		if err != nil {
			return err
		}
		defer rows.Close()
		for rows.Next() {
			if err := q.ScanRow(rows); err != nil {
				return err
			}
		}
		if err := rows.Close(); err != nil {
			return err
		}
		return rows.Err()
	case QueryExecLastID:
		result, err := e.db.ExecContext(ctx, q.SQL(), q.Args()...)
		if err != nil {
			return err
		}
		lastID, err := result.LastInsertId()
		if err != nil {
			return err
		}
		q.SetLastInsertID(lastID)
		n, err := result.RowsAffected()
		if err != nil {
			return err
		}
		q.SetRowsAffected(n)
		return nil
	case QueryExec:
		result, err := e.db.ExecContext(ctx, q.SQL(), q.Args()...)
		if err != nil {
			return err
		}
		n, err := result.RowsAffected()
		if err != nil {
			return err
		}
		q.SetRowsAffected(n)
		return nil
	default:
		return nil
	}
}

// Compile-time interface checks
var (
	_ DBTX       = (*sql.DB)(nil)
	_ DBTX       = (*sql.Conn)(nil)
	_ DBTX       = (*sql.Tx)(nil)
	_ DBTXWithTx = (*sql.DB)(nil)
	_ DBTXWithTx = (*sql.Conn)(nil)
)
